<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Functional Programming: Principles and Practice</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.1.0/reset.min.css" type="text/css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.1.0/reveal.min.css" type="text/css">
    <link rel="stylesheet" href="./nord.css" type="text/css">

    <!-- Highlight.js for syntax highlighting -->
    <link rel="stylesheet" href="./highlight/styles/nord.css">

    <style>
      .reveal pre {
        width: 100%;
        font-size: 0.6em;
      }
      .reveal code {
        max-height: 500px;
        border-radius: 5px;
      }
    </style>

    <!-- Load scripts in head -->
    <script src="./highlight/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.1.0/reveal.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.1.0/plugin/math/math.min.js"></script>

  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <!-- Title Slide -->
        <section>
          <h1>Functional Programming</h1>
        </section>

        <!-- What is Functional Programming? -->
        <section>
          <section>
            <h2>The what</h2>
          </section>
        </section>
        <section>
          <section><h3>Functions</h3></section>
          <section>
            <p>Programs as mathematical functions</p>
            <ul>
              <li class="fragment">A relation between a set of inputs and a set of possible outputs</li>
              <li class="fragment">The function itself defines and represents the relationship</li>
              <li class="fragment">Can only operate on inputs</li>
              <li class="fragment">The same inputs will always provide the same output</li>
            </ul>
          </section>
          <section>
            <h2>Examples</h2>
            <p>Valid function</p>
            \[ \begin{aligned} f(1) &amp; = A \\ f(2) &amp; = A \\ f(3) &amp; = B \end{aligned} \]
          </section>
          <section>
            <h2>Examples</h2>
            <p>Invalid function</p>
            \[ \begin{aligned} f(1) &amp; = A \\ f(1) &amp; = B \\ f(2) &amp; = C \end{aligned} \]
          </section>
          <section>
            <pre>
              <code class="python">
# Non-functional approach
tax_rate = 0.2
def calculate_tax(income):
    return income * tax_rate


# Functional approach
def calculate_tax(income, tax_rate):
    return income * tax_rate
              </code>
            </pre>
          </section>
        </section>

        <!-- Referential Transparency -->
        <section>
          <section>
            <h2>Referential Transparency</h2>
            <p>A function always produces the same output for the same input</p>
          </section>
          <section>
            <h3>Making Functions Pure</h3>
            <pre><code class="python">
# Impure random function
import random
def get_random_number():
    return random.random()  # Different output each time

# Pure random function with seed
def get_random_number(seed):
    return random.random()

# Guaranteed same output for same seed
print(get_random_number(42))  # Always returns same value
print(get_random_number(42))  # Repeatable result
            </code></pre>
          </section>
        </section>

        <!-- Arity -->
        <section>
          <section>
            <h2>Arity in Functional Programming</h2>
            <p>The number of arguments a function takes</p>
          </section>
          <section>
            <h3>Examples</h3>
            <pre><code class="r">
# Function with different arities
f0 <- function() {
    return(42)  # Zero-arity function
}

f1 <- function(x) {
    return(x * 2)  # Unary function
}

f2 <- function(x, y) {
    return(x + y)  # Binary function
}

f3 <- function(x, y, z) {
    return(x * y + z)  # Ternary function
}

# Demonstrating different function calls
print(f0())        # 42
print(f1(5))       # 10
print(f2(3, 4))    # 7
print(f3(2, 3, 1)) # 7
            </code></pre>
          </section>
        </section>

        <!-- Currying -->
        <section>
          <section>
            <h2>Currying</h2>
            <p>Transforming a function with more than one argument into a sequence of functions, each taking 1 argument</p>
          </section>
          <section>
            <h3>Example</h3>
            <pre><code class="python">
# Traditional multi-argument function
def multiply(x, y):
    return x * y

# Curried version
def multiply_curried(x):
    def inner(y):
        return x * y
    return inner

double = multiply_curried(2)

print(double(6))              # 12
print(multiply_curried(3)(4)) # 12
print(multiply_curried(3, 4)) # ERROR
            </code></pre>
          </section>
          <section>
            <h3>Example</h3>
            <pre><code class="python">
# Easier way: define a decorator
def curry(func):
    def curried(*args, **kwargs):
        if len(args) + len(kwargs) >= func.__code__.co_argcount:
            return func(*args, **kwargs)
        return (lambda *args2, **kwargs2:
                curried(*(args + args2), **dict(kwargs, **kwargs2)))
    return curried

@curry
def multiply_decorated(x, y):
    return x * y

# Usage
print(multiply_decorated(3)(4))  # 12
print(multiply_decorated(3, 4))  # 12
            </code></pre>
          </section>
        </section>

        <!-- Tail Recursion -->
        <section>
          <section>
            <h2>Tail Recursion</h2>
          </section>
          <section>
            <p>
              Tail recursion is when a function calls itself as the very last thing it
              does, allowing the computer to replace the current function call with a
              new one instead of stacking up memory.
            </p>
          </section>
          <section>
            <h3>Why??</h3>
            <p>Lots of problems suit this kind of approach</p>
          </section>
          <section>
            <h3>Example</h3>
            <pre><code class="r">
library(TailCall)

# Tail-recursive factorial function
factorial_tail <- function(n, acc = 1) {
    if (n <= 1) {
        return(acc)
    }

    # Use tail_call for proper tail recursion optimization
    tail_call(factorial_tail, n - 1, n * acc)
}

# Example usage
result <- factorial_tail(5)
print(result)  # Computes 5! = 120 efficiently
            </code></pre>
          </section>

          <section>
            <h3>Python</h3>does not optimise tail calls, so <h4 id="no">don't do it</h4>
          </section>
        </section>

        <!-- Higher Order Functions -->
        <section>
          <section>
            <h2>Higher Order Functions</h2>
            <p>Functions that can take other functions as arguments or return functions</p>
          </section>
          <section>
            <p>Imagine you have a magic toy box that can change toys for you!
               Higher order functions are like special magic toy boxes in programming.</p>
          </section>
          <section>
            <ul>
              <li>They can take other toys (functions) as gifts</li>
              <li>They can create new toy-changing instructions</li>
              <li>They help you do cool things with toys more easily, like sorting or changing them quickly</li>
            </ul>
          </section>
          <section>
            <p>For example, in R or Python, a higher order function like <span id="mono">map()</span>
              can take a toy-changing rule and apply it to ALL your toys at once, instead of changing each
              toy one by one. It's like having a magic helper that does repetitive work super fast!
          </section>
          <section>
            <h3>Example</h3>
            <pre><code class="r">
# Higher order function that applies a function multiple times
apply_n_times <- function(f, n) {
    function(x) {
        result <- x
        for(i in 1:n) {
            result <- f(result)
        }
        return(result)
    }
}

# Create a function that doubles a value twice
double_twice <- apply_n_times(function(x) x * 2, 2)

# Usage
print(double_twice(3))  # 3 -> 6 -> 12

            </code></pre>
          </section>
        </section>

        <!-- Functors in Python -->
        <section>
          <section>
            <h2>Functors</h2>
          </section>
          <section>
            <p>We just talked about maps</p>
            <p>A <span id="bold">functor</span> is a container that can be mapped over using a function
              while preserving the structure</p>
          </section>
          <section>
            <p>Isn't that just a list?</p>
            <p class="fragment"><span id="no">No!</span></p>
            <p class="fragment">There are many useful functors which aren't lists:</p>
            <ul class="fragment">
              <li>Optional data types</li>
              <li>Generator expressions</li>
              <li>Iterator types</li>
              <li>Dictionary mappings</li>
            </ul>
          </section>
          <section>
            <h3>Examples</h3>
            <pre><code class="python">
from dataclasses import dataclass
from typing import Optional, Iterator, Any

@dataclass
class Tree:
    value: Any
    left: Optional['Tree'] = None
    right: Optional['Tree'] = None

    def __iter__(self) -> Iterator[Any]:
        # In-order traversal
        if self.left:
            yield from self.left
        yield self.value
        if self.right:
            yield from self.right
            </code></pre>
          </section>
          <section>
            <h3>Examples</h3>
            <pre><code class="python">
    def __next__(self) -> Any:
        # This makes the tree itself an iterator
        raise NotImplementedError("Use __iter__ for iteration")

# Create a sample tree
tree = Tree(
    value=5,
    left=Tree(3, Tree(1), Tree(4)),
    right=Tree(7, Tree(6), Tree(8))
)

# Iterate through the tree
for value in tree:
    print(value)  # Prints: 1, 3, 4, 5, 6, 7, 8
            </code></pre>
          </section>
          <section>
            Here are some Python functor examples beyond lists:

            1. Optional/Maybe Types
            ```python
            from typing import Optional

            class Optional:
            def map(self, func):
            return func(self.value) if self.value is not None else None
            ```

            2. Generator Comprehensions
            ```python
            def generator_map(gen, func):
            return (func(x) for x in gen)
            ```

            3. Iterator Types
            ```python
            class MappableIterator:
            def map(self, func):
            return map(func, self.items)
            ```

            4. Custom Container Classes
            ```python
            class CustomContainer:
            def __init__(self, value):
            self._value = value

            def map(self, func):
            return CustomContainer(func(self._value))
            ```

            5. Dictionary Mapping
            ```python
            def dict_map(d, func):
            return {k: func(v) for k, v in d.items()}
            ```

            These examples demonstrate how different data structures can implement functor-like behavior through mapping operations that transform contained values while preserving their original structure.
        </section>

        </section>

        <!-- Pure Functions -->
        <section>
          <section>
            <h2>Pure Functions</h2>
            <p>Functions with no side effects that always return the same output for the same input</p>
          </section>
          <section>
            <h3>Python Example</h3>
            <pre><code class="python">
# Impure function
processed_items = []
def process_data(data):
    for item in data:
        processed_items.append(item * 2)
    return processed_items

# Pure function
def process_data(data):
    return [item * 2 for item in data]
            </code></pre>
          </section>
        </section>

        <!-- Why Functional Programming? -->
        <section>
          <h2>Benefits of Functional Programming</h2>
          <ul>
            <li>Reduces Bug Types:
              <ul>
                <li>Eliminates state mutation bugs</li>
                <li>Prevents unintended side effects</li>
                <li>Reduces race conditions in concurrent code</li>
                <li>Minimises global state-related errors</li>
              </ul>
            </li>
            <li>Easier to test and debug</li>
            <li>More predictable code</li>
            <li>Simplified parallel processing</li>
            <li>Reduced state complexity</li>
          </ul>
        </section>

        <!-- Functional Programming in Python/R -->
        <section>
          <section>
            <h2>Functional Programming in Python/R</h2>
            <p>Built-in functional programming support</p>
          </section>
          <section>
            <h3>Python Functional Tools</h3>
            <pre><code class="python">
# Map, Filter, Reduce
from functools import reduce

numbers = [1, 2, 3, 4, 5]

# Map
squared = list(map(lambda x: x**2, numbers))

# Filter
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))

# Reduce
product = reduce(lambda x, y: x * y, numbers)
            </code></pre>
          </section>
        </section>

        <!-- Learning Resources -->
        <section>
          <h2>Learn More About Functional Programming</h2>
          <ul>
            <li>Books:
              <ul>
                <li>"Functional Programming in Python" by Steven Lott</li>
                <li>"Functional Programming in R" by Thomas Mailund</li>
              </ul>
            </li>
            <li>Online Courses: Coursera, edX functional programming courses</li>
            <li>Websites: Real Python, GeeksforGeeks</li>
          </ul>
        </section>

        <!-- Languages to Explore -->
        <section>
          <h2>Functional Programming Languages</h2>
          <ul>
            <li>Haskell (Pure functional)</li>
            <li>Clojure (Lisp dialect)</li>
            <li>Scala (Functional + Object-Oriented)</li>
            <li>Erlang (Concurrent functional)</li>
            <li>F# (Functional .NET language)</li>
          </ul>
        </section>

        <!-- Closing Slide -->
        <section>
          <h2>Functional Programming</h2>
          <p>A powerful paradigm that can transform how you think about coding</p>
        </section>
      </div>
    </div>

    <script>
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'slide',
        plugins: [RevealHighlight]
      });
    </script>
  </body>
</html>
<body>
  <div class="reveal">
    <div class="slides">
      <!-- Title Slide -->
      <section>
        <h1>Functional Programming</h1>
        <h3>Transforming How We Think About Code</h3>
      </section>

      <!-- What is Functional Programming? -->
      <section>
        <section>
          <h2>What is Functional Programming?</h2>
          <p>A programming paradigm that models programs as combinations of mathematical functions</p>
        </section>
        <section>
          <h3>Mathematical Function Analogy</h3>
          <pre><code class="python">
# Non-functional approach
def calculate_tax(income):
    global tax_rate
    tax_rate = 0.2  # Side effect: modifying global state
    return income * tax_rate

# Functional approach
def calculate_tax(income, tax_rate):
    return income * tax_rate
          </code></pre>
        </section>
      </section>

      <!-- Referential Transparency -->
      <section>
        <section>
          <h2>Referential Transparency</h2>
          <p>A function always produces the same output for the same input</p>
        </section>
        <section>
          <h3>Example in Python</h3>
          <pre><code class="python">
# Non-transparent function
import random

def get_random_number():
    return random.random()  # Different output each time

# Transparent function
def square(x):
    return x * x  # Always the same output for same input
          </code></pre>
        </section>
      </section>

      <!-- Pure Functions -->
      <section>
        <section>
          <h2>Pure Functions</h2>
          <p>Functions with no side effects that always return the same output for the same input</p>
        </section>
        <section>
          <h3>Python Example</h3>
          <pre><code class="python">
# Impure function
def process_data(data):
    global processed_items
    processed_items = []
    for item in data:
        processed_items.append(item * 2)
    return processed_items

# Pure function
def process_data(data):
    return [item * 2 for item in data]
          </code></pre>
        </section>
      </section>

      <!-- Tail Recursion -->
      <section>
        <section>
          <h2>Tail Recursion</h2>
          <p>A recursive function where the recursive call is the last operation</p>
        </section>
        <section>
          <h3>Python Tail Recursion</h3>
          <pre><code class="python">
# Traditional recursion
def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n - 1)

# Tail recursion (conceptual - Python doesn't optimize tail calls)
def factorial_tail(n, accumulator=1):
    if n == 0:
        return accumulator
    return factorial_tail(n - 1, n * accumulator)
          </code></pre>
        </section>
      </section>

      <!-- Immutable Data -->
      <section>
        <section>
          <h2>Immutable Data</h2>
          <p>Data that cannot be changed after creation</p>
        </section>
        <section>
          <h3>Python Immutability</h3>
          <pre><code class="python">
# Mutable approach
def add_to_list(lst, item):
    lst.append(item)
    return lst

# Immutable approach
def add_to_list(lst, item):
    return lst + [item]

# Using tuples for immutability
point = (10, 20)
# point[0] = 15  # This would raise an error
          </code></pre>
        </section>
      </section>

      <!-- Why Functional Programming? -->
      <section>
        <h2>Benefits of Functional Programming</h2>
        <ul>
          <li>Easier to test and debug</li>
          <li>More predictable code</li>
          <li>Simplified parallel processing</li>
          <li>Reduced state complexity</li>
        </ul>
      </section>

      <!-- Functional Programming in Python/R -->
      <section>
        <section>
          <h2>Functional Programming in Python/R</h2>
          <p>Built-in functional programming support</p>
        </section>
        <section>
          <h3>Python Functional Tools</h3>
          <pre><code class="python">
# Map, Filter, Reduce
from functools import reduce

numbers = [1, 2, 3, 4, 5]

# Map
squared = list(map(lambda x: x**2, numbers))

# Filter
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))

# Reduce
product = reduce(lambda x, y: x * y, numbers)
          </code></pre>
        </section>
      </section>

      <!-- Learning Resources -->
      <section>
        <h2>Learn More About Functional Programming</h2>
        <ul>
          <li>Books: "Functional Programming in Python" by Steven Lott</li>
          <li>Online Courses: Coursera, edX functional programming courses</li>
          <li>Websites: Real Python, GeeksforGeeks</li>
        </ul>
      </section>

      <!-- Languages to Explore -->
      <section>
        <h2>Functional Programming Languages</h2>
        <ul>
          <li>Haskell (Pure functional)</li>
          <li>Clojure (Lisp dialect)</li>
          <li>Scala (Functional + Object-Oriented)</li>
          <li>Erlang (Concurrent functional)</li>
          <li>F# (Functional .NET language)</li>
        </ul>
      </section>

      <!-- Closing Slide -->
      <section>
        <h2>Functional Programming</h2>
        <p>A powerful paradigm that can transform how you think about coding</p>
      </section>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.1.0/reveal.min.js"></script>
  <script>
    Reveal.initialize({ plugins: [RevealMath.KaTeX] });
    hljs.highlightAll();
    Reveal.initialize({
      controls: true,
      progress: true,
      history: true,
      center: true,
      transition: 'fade'
    });
  </script>
</body>
</html>
